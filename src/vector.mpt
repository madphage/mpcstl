#ifndef mptDeclare
#define mptDeclare 1
#endif

#ifndef mptDefine
#define mptDefine 0
#endif

#ifndef VectorITEM
#error "Must define VectorITEM"
#endif

#ifndef VectorITEM_primitive
#define VectorITEM_primitive 0
#endif

#define mptTypeName CAT(V, VectorITEM)
#define mptStructName CAT(_V, VectorITEM)
#define mptTypeFunc(fname) CAT3(mptTypeName, _, fname)

#if mptDeclare

#include "macro_utils.h"

#ifndef Vector_INCLUDE_ONCE
#define Vector_INCLUDE_ONCE
typedef MptStatus (*Vector_push_func)(void * v, void * item);
typedef uint32_t (*Vector_len_func)(void * v);
typedef uint32_t (*Vector_alloc_len_func)(void * v);
typedef MptStatus (*Vector_item_func)(void * v, uint32_t index, void * item_ptr);

typedef struct _VectorClass {
	Vector_push_func push;
	Vector_len_func len;
	Vector_alloc_len_func alloc_len;
	Vector_item_func item;
} VectorClass;

typedef struct _Obj {
	void * obj;
	const VectorClass * cls;
} VectorObj;

typedef struct _VecHeader {
	uint32_t available;
	uint32_t used;
} VecHeader;

uint32_t VecHeader_len(VecHeader * v);
uint32_t VecHeader_alloc_len(VecHeader * v);

#define Vector_declare(name, vtypename, sz) \
	VectorObj name  = { .cls = &CAT(vtypename, Class), .obj = NULL }; \
	name.obj = CAT(vtypename, _mk_prealloc)(sz)

#endif

typedef struct mptStructName {
	uint32_t available;
	uint32_t used;
	VectorITEM * items;
} mptTypeName;

mptTypeName * mptTypeFunc(mk_prealloc)(uint32_t num_entries);

MptStatus mptTypeFunc(push)(mptTypeName * vec, VectorITEM * item);
MptStatus mptTypeFunc(item)(mptTypeName * vec, uint32_t index, VectorITEM * item);

static const VectorClass CAT(mptTypeName, Class) = {
	.len		= (Vector_len_func) VecHeader_len,
	.alloc_len	= (Vector_alloc_len_func) VecHeader_alloc_len,
	.push		= (Vector_push_func) mptTypeFunc(push),
	.item		= (Vector_item_func) mptTypeFunc(item),
};

#endif //mptDeclare

#if mptDefine

#ifndef Vector_DEFINE_ONCE
#define Vector_DEFINE_ONCE
uint32_t VecHeader_len(VecHeader * v) { return v->used; }
uint32_t VecHeader_alloc_len(VecHeader * v) { return v->available; }

#endif

mptTypeName * mptTypeFunc(mk_prealloc)(uint32_t num_entries) {
	mptTypeName * res = NULL;
	mptTypeName * tmp = NULL;
	uint8_t * items = NULL;

	items = calloc(num_entries, sizeof(VectorITEM));
	if (!items) {
		goto Exit;
	}

	tmp = calloc(1, sizeof(mptTypeName));
	if (!tmp) {
		goto Exit;
	}

	tmp->available = num_entries;
	// tmp->used = 0; # inherited from calloc
	tmp->items = (VectorITEM *) items;
	items = NULL;

	res = tmp;
	tmp = NULL;

Exit:
	if (items) {
		free(items);
		items = NULL;
	}

	if (tmp) {
		free(tmp);
		tmp = NULL;
	}
	
	return res;
}

#if VectorITEM_primitive
MptStatus mptTypeFunc(push)(mptTypeName * vec, VectorITEM * item) {
	MptStatus res = MptUnexpected;
	NOTNULL(vec);
	NOTNULL(item);

	if (vec->used < vec->available) { // we have space
		vec->items[vec->used] = *item;
		vec->used++;
	} else {
		VectorITEM * tmp_items = NULL;
		// Here we need to realloc
		if (vec->available * 2 < vec->available) {
			FAIL(MptIntOverflow);
		}

		tmp_items = realloc(vec->items, vec->available * 2);
		
		NOTNULL(tmp_items);

		vec->items = tmp_items;
	}

	res = MptSuccess;

Exit:
	return res;
}
#else
#error "haven't defined struct push yet"
#endif

#if VectorITEM_primitive
MptStatus mptTypeFunc(item)(mptTypeName * vec, uint32_t index, VectorITEM * item) {
	MptStatus res = MptUnexpected;
	NOTNULL(vec);

	if (index < vec->used) {
		*item = vec->items[index];
		res = MptSuccess;
	} else {
		res = MptFailure;
	}
Exit:
	return res;
}
#else
#error "haven't defined struct item yet"
#endif

#endif //mptDefine

#undef mptTypeName
#undef mptTypeFunc

#undef mptDeclare
#undef mptDefine
#undef VectorITEM
#undef VectorITEM_primitive



